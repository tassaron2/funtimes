#!/usr/bin/env python3
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=#
#
# funquests.py
# created by tassaron 2017/04/05
#
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=#
#
# Generates a pred file containing random connected rooms.
#
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=#
import os
import argparse
import random

PREDDIR = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'pred','funquests')
NamesInUse = []

class Predicament:
    def __init__(self, predname, backArrow, keepGoing):
        self.predname = predname
        self.backGoto=''
        self.backDirection=''
        
        def directions():
            '''choose 1-4 unique directions'''
            arrows = ['up', 'down', 'left', 'right']
            if backArrow[1]:
                arrows.remove(reverseDirection(backArrow[1]))
            choices = [random.choice(arrows)]
            gotos = []
            for i in range(3):
                nextchoice = random.choice(arrows)
                if nextchoice not in choices:
                    choices.append(nextchoice)
                    gotos.append(unique(predname))
                    
            return choices, gotos
    
        if keepGoing:
            self.directions, self.directionGoto = directions()
        else:
            self.directions = []
            self.directionGoto = []
        if backArrow[0] is not None:
            self.backGoto = backArrow[0]
            self.backDirection = reverseDirection(backArrow[1])

class QuestMap:
    def __init__(self, predname):
        # a dictionary of created predicaments for createPredFile()
        self.predicaments = {}
        # preds that still neeed to be created before this map can be done
        # { 'predname' : (pred that points to it, direction that pred is) }
        self.predsToCreate = {}
        # now create the first pred: an entrypoint
        self.newPredicament('%sentry' % predname,\
                            backArrow=(None, None), keepGoing=True)
                            
        # now generate preds until we reach totalPreds!
        totalPreds = random.randint(6, 10)
        generatedPreds = 1
        while True:
            iterator = dict(self.predsToCreate)
            for predname, backArrow in iterator.items():
                self.predsToCreate.pop(predname)
                generatedPreds+=1
                keepGoing = (generatedPreds < totalPreds)
                self.newPredicament(predname, backArrow, keepGoing)
            if not iterator:
                break
                

    def newPredicament(self, predname, backArrow, keepGoing):
        print(predname)
        if predname in self.predicaments:
            print('WTF'); quit()
        # make a new Predicament object
        newpred = Predicament(predname, backArrow,keepGoing)
        self.predicaments[predname] = newpred
        # add its directions to the predsToCreate
        backDirection = reverseDirection(backArrow[1])
        for goto, direction in zip(newpred.directionGoto, newpred.directions):
            if direction != backDirection:
                self.predsToCreate[goto] = (predname, direction)
        
def reverseDirection(string):
    if string is not None:
        if string=='up':
            return 'down'
        elif string=='down':
            return 'up'
        elif string=='left':
            return 'right'
        elif string=='right':
            return 'left'
        else:
            print('Not a direction')

def unique(string):
    global NamesInUse
    if string[-5:] == 'entry':
        string = string[:-5]
    else:
        string = string[:-3]
    while True:
        rndNum = random.randint(100,999)
        predname = '%s%s' % (string, rndNum)
        if predname not in NamesInUse:
            break
    return predname

def write(text):
    fp.write('%s\n' % text)

def writePredicament(predname, predobj):
    write('')
    write('predicament = %s' % predobj.predname)
    write('    map = auto')
    write('    dude = Y -> you')
    write('    text = %predname%')
    if predobj.backDirection:
        write('    %s = %s' % (predobj.backDirection, predobj.backGoto))
    for direction, goto in zip(predobj.directions, predobj.directionGoto):
        write('    %s = %s' % (direction, goto))
    write('/predicament')

def createPredFile(predname):
    global fp
    with open(os.path.join(PREDDIR, '%s.pred' % predname), 'w') as fp:
        write('generated by funquests.py')
        write('version = 1')
        questMap = QuestMap(predname)
        for predname, predobj in questMap.predicaments.items():
            writePredicament(predname, predobj)
        
def main():
    # first parse command line arguments
    parser = argparse.ArgumentParser(description='creates a pred file containing a funtimes quest')
    parser.add_argument('predname', help='name of pred file')
    arg = vars(parser.parse_args()) # return arguments as a dictionary
    createPredFile(arg['predname'])

if __name__ == '__main__':
    main()
